(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{424:function(e,r,t){"use strict";t.r(r);var _=t(11),v=Object(_.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"mock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mock"}},[e._v("#")]),e._v(" Mock")]),e._v(" "),t("p",[e._v("Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发更加独立自主，不会被服务端的开发所阻塞。")]),e._v(" "),t("h2",{attrs:{id:"swagger"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#swagger"}},[e._v("#")]),e._v(" Swagger")]),e._v(" "),t("p",[e._v("在公司的项目中通常使用 "),t("a",{attrs:{href:"https://swagger.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("swagger"),t("OutboundLink")],1),e._v("， 由后端来模拟业务数据。\n"),t("strong",[e._v("swagger")]),e._v(" 是一个 REST APIs 文档生成工具，它从代码注释中自动生成文档，可以跨平台，开源，支持大部分语言，社区好，总之非常不错，强烈推荐。\n"),t("a",{attrs:{href:"http://petstore.swagger.io/?_ga=2.222649619.983598878.1509960455-2044209180.1509960455#/pet/addPet",target:"_blank",rel:"noopener noreferrer"}},[e._v("线上 demo"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"mockjs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mockjs"}},[e._v("#")]),e._v(" Mockjs")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/nuysoft/Mock",target:"_blank",rel:"noopener noreferrer"}},[e._v("mockjs"),t("OutboundLink")],1),e._v(" 的原理是: 拦截了所有的请求并代理到本地，然后进行数据模拟，所以你会发现 "),t("code",[e._v("network")]),e._v(" 中没有发出任何的请求。")]),e._v(" "),t("p",[e._v("但它的最大的问题是就是它的实现机制。它会重写浏览器的"),t("code",[e._v("XMLHttpRequest")]),e._v("对象，从而才能拦截所有请求，代理到本地。大部分情况下用起来还是蛮方便的，但就因为它重写了"),t("code",[e._v("XMLHttpRequest")]),e._v("对象，所以比如"),t("code",[e._v("progress")]),e._v("方法，或者一些底层依赖"),t("code",[e._v("XMLHttpRequest")]),e._v("的库都会和它发生不兼容。")]),e._v(" "),t("p",[e._v("它还有一个问题是，因为是它本地模拟的数据，实际上不会走任何网络请求。所以本地只能通过"),t("code",[e._v("console.log")]),e._v("来调试。")]),e._v(" "),t("h2",{attrs:{id:"目前方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目前方案"}},[e._v("#")]),e._v(" 目前方案")]),e._v(" "),t("p",[e._v("在本地会启动一个"),t("code",[e._v("mock-server")]),e._v("来模拟数据，该方案的好处是，在保留 "),t("code",[e._v("mockjs")]),e._v("的优势的同时，解决之前的痛点。由于我们的 mock 是完全基于"),t("code",[e._v("webpack-dev-serve")]),e._v("来实现的，所以在你启动前端服务的同时，"),t("code",[e._v("mock-server")]),e._v("就会自动启动，而且这里还通过 "),t("a",{attrs:{href:"https://github.com/paulmillr/chokidar",target:"_blank",rel:"noopener noreferrer"}},[e._v("chokidar"),t("OutboundLink")],1),e._v(" 来观察 "),t("code",[e._v("mock")]),e._v(" 文件夹内容的变化。在发生变化时会清除之前注册的"),t("code",[e._v("mock-api")]),e._v("接口，重新动态挂载新的接口，从而支持热更新。由于是一个真正的"),t("code",[e._v("server")]),e._v("，所以你可以通过控制台中的"),t("code",[e._v("network")]),e._v("，清楚的知道接口返回的数据结构。并且同时解决了之前"),t("code",[e._v("mockjs")]),e._v("会重写 "),t("code",[e._v("XMLHttpRequest")]),e._v("对象，导致很多第三方库失效的问题。")]),e._v(" "),t("p",[e._v("通过阅读源码可以发现所有的"),t("code",[e._v("请求")]),e._v("都设置了一个 BASE_URL，而这个 BASE_URL 又是通过读取 process.env.VUE_APP_API_BASE_URL 这个环境变量来动态设置的，这样方便我们做到不同环境使用不同的 api 地址。")]),e._v(" "),t("h2",{attrs:{id:"移除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#移除"}},[e._v("#")]),e._v(" 移除")]),e._v(" "),t("p",[e._v("如果你不想使用"),t("code",[e._v("mock-server")]),e._v("的话只需要修改"),t("code",[e._v(".env.development")]),e._v("将"),t("code",[e._v("process.env.VUE_APP_API_BASE_URL")]),e._v("指向对应服务器的地址并以"),t("code",[e._v("dev")]),e._v("命令启动项目就可以了。")]),e._v(" "),t("h2",{attrs:{id:"新增"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新增"}},[e._v("#")]),e._v(" 新增")]),e._v(" "),t("p",[e._v("如果你想添加 mock 数据，需要先在"),t("code",[e._v("packages/pan-spatial-map-mock-server/mock/swagger.yml")]),e._v("中定义接口，然后在"),t("code",[e._v("packages/pan-spatial-map-mock-server/mock/app/")]),e._v("某个文件内实现该接口，最后在"),t("code",[e._v("packages/pan-spatial-map-mock-server/mock/api.ts")]),e._v("中引入该文件即可。")])])}),[],!1,null,null,null);r.default=v.exports}}]);